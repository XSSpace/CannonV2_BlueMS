/**
  ******************************************************************************
  * @file    main.c
  * @author  Central LAB
  * @version V3.1.0
  * @date    12-July-2017
  * @brief   Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */

/**
 * @mainpage FP-SNS-MOTENV1 Bluetooth Low Energy and Sensors Software
 *
 * @image html st_logo.png
 *
 * <b>Introduction</b>
 *
 * This firmware package includes Components Device Drivers, Board Support Package
 * and example application for the following STMicroelectronics elements:
 * - X-NUCLEO-IDB04A1/X-NUCLEO-IDB05A1 Bluetooth Low energy expansion boards
 * - X-NUCLEO-IKS01A1 Expansion board for four MEMS sensor devices:
 *       HTS221, LPS25H, LSM6DS0, LSM6DS3, LIS3MDL
 * - X-NUCLEO-IKS01A2 Expansion board for four MEMS sensor devices:
 *     HTS221, LPS22HB, LSM6DSL, LSM303AGR
 * - NUCLEO-L053R8 NUCLEO-F401RE NUCLEO-L476RG Nucleo boards
 * - STEVAL-STLCS01V1 (SensorTile) evaluation board that contains the following MEMS sensor devices:
 *      HTS221, LPS22HB, LSM303, LSM6DSM
 * - MotionFX (iNEMOEngine PRO) suite uses advanced algorithms to integrate outputs
 * from multiple MEMS sensors in a smartway, independent of environmental conditions,
 * to reach optimal performance. Real-time motion-sensor data fusion is set to significantly
 * improve the user experience, increasing accuracy, resolution, stability and response time.
 * - MotionAR (iNEMOEngine PRO) software provides real-time activity recognition data 
 * using MEMS accelerometer sensor
 * - MotionCP (iNEMOEngine PRO) software provides carry Position recognition data 
 * using MEMS accelerometer sensor
 * - MotionGR (iNEMOEngine PRO) software provides carry Gesture recognition data 
 * using MEMS accelerometer sensor
 * - MotionPM (iNEMOEngine PRO) software provides Pedometer recognition data 
 * using MEMS accelerometer sensor
 * - MotionID (iNEMOEngine PRO) software provides real-time Motion Intensity recognition data 
 * using MEMS accelerometer sensor
 *
 * <b>Example Application</b>
 *
 * The Example application initizializes all the Components and Library creating 4 Custom Bluetooth services:
 * - The first service exposes all the HW characteristics related to MEMS sensor devices: Temperature, Humidity,
 * Pressure, Magnetometer, Gyroscope and Accelleromenter, LED status
 * - The second service exposes the SW characteristic: the quaternions generated by the MotionFX library 
 * in short precision, the activity recognized using the MotionAR algorithm, the carry position
 * recognized using the MotionCP algorithm, the Gesture recognized using the MotionGR,
 * the Motion Intensity recognized using the MotionID algorithm and the Steps and frequency with MotionPM
 * - The Third Service exposes the console services where we have stdin/stdout and stderr capabilities
 * - The last Service is used for configuration purpose
 *
 * For NUCLEO boards (STM32F401RE/STM32L476RG) the example application allows the user to control the initialization phase via UART.
 * Launch a terminal application and set the UART port to 460800 bps, 8 bit, No Parity,
 * 1 stop bit.For having the same UART functionality on SensorTile board, is necessary to recompile the code uncomment the line
 *      //#define MOTENV1_ENABLE_PRINTF
 * on file:
 *      Projects\Multi\Applications\MOTENV1\Inc\MOTENV1_config.h file
 * This enables the UART that starts with a delay of 10 Seconds for allowing the time to open the UART for looking the initialization phase
 *
 * This example must be used with the related BlueMS Android/iOS application available on Play/itune store,
 * in order to read the sent information by Bluetooth Low Energy protocol
 *
 *                              -----------------------
 *                              | VERY IMPORTANT (1): |
 *                              -----------------------
 * The implementation for Nucleo-F401RE/Nucleo-L476RG and STEVAL-STLCS01V1 allow the Firmware-Over-The-Air (FOTA).
 * The FOTA is not available for Nucleo-L053R8 for FLASH size that is too little.
 *
 * ONLY for the implementations where FOTA is supported (Nucleo-F401RE/Nucleo-L476RG and STEVAL-STLCS01V1):
 * 
 * 1) The Firmware-Over-The-Air (FOTA) is done using the BlueMS Android/iOS application (Version 3.0.0 and above)
 * The FOTA does not work when using X-NUCLEO-IDB04A1
 *
 * 2) This example must run starting at address 0x08004000 in memory and works ONLY if the BootLoader 
 * is saved at the beginning of the FLASH (address 0x08000000)
 *
 * The implementation of NUCLEO-L053R8 must run at the usual FLASH address (address 0x08000000) and the BootLoader must be avoided.
 *
 * For each IDE (IAR/ÂµVision/System Workbench), and for each platform (NUCLEO-F401RE/NUCLEO-L476RG/SensorTile),
 *  there are some scripts CleanMotEnv1.bat/CleanMotEnv1.sh that makes the following operations:
 * - Full Flash Erase
 * - Load the BootLoader on the right flash region
 * - Load the Program (after the compilation) on the right flash region (This could be used for a FOTA)
 * - Dump back one single binary that contain BootLoader+Program that could be
 *  flashed at the flash beginning (address 0x08000000) (This COULD BE NOT used for FOTA)
 * - Reset the board
 * .
 *
 *                              -----------------------
 *                              | VERY IMPORTANT (2): |
 *                              -----------------------
 * The code for STM32L476RG-Nucleo and for TM32F401RE-Nucleo makes the auto discovery 
 * of the Sensors Board attached (IKS01A1/IKS01A2).
 * The code for STM32L053R8-Nucleo has not this functionality.
 * So it's necessary to choose the right Target configuration during the compilation.
 * If the code is compiled for IKS01A1 could not run if it's attached the X-NUCLEO-IKS01A2 and vice versa.
 *
 *                              -----------------------
 *                              | VERY IMPORTANT (3): |
 *                              -----------------------
 * The Motion Libraries MotionFX, MotionAR, MotionCP, MotionGR, MotionID and MotionPM are available for
 * Nucleo-F401RE/Nucleo-L476RG and STEVAL-STLCS01V1 (excluding Nucleo-L053R8).
 */

/* Includes ------------------------------------------------------------------*/
#include <stdio.h>
#include <math.h>
#include <limits.h>
#include "TargetFeatures.h"
#include "main.h"

#ifndef USE_STM32L0XX_NUCLEO
  #include "MetaDataManager.h"
  #include "OTA.h"
#endif /* USE_STM32L0XX_NUCLEO */
   
#include "sensor_service.h"
#include "bluenrg_utils.h"
#include "HWAdvanceFeatures.h"

/* Private typedef -----------------------------------------------------------*/

/* Private define ------------------------------------------------------------*/

#define BLUEMSYS_N_BUTTON_PRESS 3
#define BLUEMSYS_CHECK_CALIBRATION ((uint32_t)0x12345678)

/* Imported Variables -------------------------------------------------------------*/
extern uint8_t set_connectable;
extern int connected;

#ifndef USE_STM32L0XX_NUCLEO
extern MAR_output_t ActivityCode;
extern MCP_output_t CarryPositionCode;
extern MGR_output_t GestureRecognitionCode;
#ifdef ENABLE_STM32_MOTION_ID
extern MID_output_t MIDCode;
#endif /* ENABLE_STM32_MOTION_ID */

extern MPM_output_t PM_DataOUT;
#endif /* USE_STM32L0XX_NUCLEO */

#ifdef STM32_SENSORTILE
  #ifdef MOTENV1_ENABLE_PRINTF
    extern TIM_HandleTypeDef  TimHandle;
    extern void CDC_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);
  #endif /* MOTENV1_ENABLE_PRINTF */
#endif /* STM32_SENSORTILE */

/* Exported Variables -------------------------------------------------------------*/

float sensitivity;
/* Acc sensitivity multiply by FROM_MG_TO_G constant */
float sensitivity_Mul;

#ifndef USE_STM32L0XX_NUCLEO
MFX_MagCal_output_t magOffset;
SensorAxes_t MAG_Offset;
#endif /* USE_STM32L0XX_NUCLEO */

uint32_t ConnectionBleStatus  =0;

uint32_t ForceReCalibration    =0;
uint32_t FirstConnectionConfig =0;

uint8_t BufferToWrite[256];
int32_t BytesToWrite;

TIM_HandleTypeDef    TimCCHandle;
TIM_HandleTypeDef    TimEnvHandle;

uint8_t bdaddr[6];

uint32_t uhCCR1_Val = DEFAULT_uhCCR1_Val;
uint32_t uhCCR4_Val = DEFAULT_uhCCR4_Val;

#ifndef USE_STM32L0XX_NUCLEO
uint32_t CalibrationData[30];

/* Table with All the known Meta Data */
MDM_knownGMD_t known_MetaData[]={
  {GMD_CALIBRATION,(sizeof(CalibrationData))},
  {GMD_END    ,0}/* THIS MUST BE THE LAST ONE */
};
#endif /* USE_STM32L0XX_NUCLEO */

/* Private variables ---------------------------------------------------------*/
static volatile int ButtonPressed        =0;
static volatile int MEMSInterrupt        =0;
static volatile uint32_t HCI_ProcessEvent=0;
static volatile uint32_t SendEnv         =0;
static volatile uint32_t SendAccGyroMag  =0;

#ifdef STM32_SENSORTILE
static volatile uint32_t SendBatteryInfo =0;
#endif /* STM32_SENSORTILE */

#ifndef USE_STM32L0XX_NUCLEO
static CRC_HandleTypeDef hcrc;
#endif /* USE_STM32L0XX_NUCLEO */

static volatile uint32_t Quaternion      =0;
static volatile uint32_t UpdateMotionAR  =0;
static volatile uint32_t UpdateMotionCP  =0;
static volatile uint32_t UpdateMotionGR  =0;
static volatile uint32_t UpdateMotionPM  =0;
#ifdef ENABLE_STM32_MOTION_ID
static volatile uint32_t UpdateMotionID  =0;
#endif /* ENABLE_STM32_MOTION_ID */

unsigned char isCal = 0;

#ifndef USE_STM32L0XX_NUCLEO
static uint32_t mag_time_stamp = 0;
#endif /* USE_STM32L0XX_NUCLEO */

/* Private function prototypes -----------------------------------------------*/
static void SystemClock_Config(void);

static void Init_BlueNRG_Custom_Services(void);
static void Init_BlueNRG_Stack(void);

#ifndef USE_STM32L0XX_NUCLEO
static unsigned char ResetCalibrationInMemory(void);

static void MX_CRC_Init(void);
#endif /* USE_STM32L0XX_NUCLEO */

static void InitTimers(void);
static void SendEnvironmentalData(void);
static void MEMSCallback(void);

#ifndef USE_STM32L0XX_NUCLEO
static void MagCalibTest(void);
static void ReCalibration(void);
#endif /* USE_STM32L0XX_NUCLEO */

static void ButtonCallback(void);
static void SendMotionData(void);

#ifdef STM32_SENSORTILE
static void SendBatteryInfoData(void);
#endif /* STM32_SENSORTILE */

#ifndef USE_STM32L0XX_NUCLEO
static void ComputeQuaternions(void);
static void ComputeMotionAR(void);
static void ComputeMotionCP(void);
static void ComputeMotionGR(void);
static void ComputeMotionPM(void);
#ifdef ENABLE_STM32_MOTION_ID
static void ComputeMotionID(void);
#endif /* ENABLE_STM32_MOTION_ID */
#endif /* USE_STM32L0XX_NUCLEO */

uint32_t t_coin=0;

/**
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
  HAL_Init();

  /* Configure the System clock */
  SystemClock_Config();

#ifdef STM32_NUCLEO
  InitTargetPlatform(TARGET_NUCLEO);
#elif STM32_SENSORTILE
  InitTargetPlatform(TARGET_SENSORTILE);
#endif /* STM32_NUCLEO */

#ifndef USE_STM32L0XX_NUCLEO
  MX_CRC_Init();
  
  /* Check the MetaDataManager */
  InitMetaDataManager((void *)&known_MetaData,MDM_DATA_TYPE_GMD,NULL);
  
#endif /* USE_STM32L0XX_NUCLEO */

  MOTENV1_PRINTF("\n\t(HAL %ld.%ld.%ld_%ld)\r\n"
        "\tCompiled %s %s"
#if defined (__IAR_SYSTEMS_ICC__)
        " (IAR)\r\n"
#elif defined (__CC_ARM)
        " (KEIL)\r\n"
#elif defined (__GNUC__)
        " (openstm32)\r\n"
#endif
         "\tSend Every %4dmS %d Short precision Quaternions\r\n"
         "\tSend Every %4dmS Temperature/Humidity/Pressure\r\n"
         "\tSend Every %4dmS Acc/Gyro/Magneto\r\n\n",
           HAL_GetHalVersion() >>24,
          (HAL_GetHalVersion() >>16)&0xFF,
          (HAL_GetHalVersion() >> 8)&0xFF,
           HAL_GetHalVersion()      &0xFF,
         __DATE__,__TIME__,
         QUAT_UPDATE_MUL_10MS*10,SEND_N_QUATERNIONS,
         500,
         50);

#ifdef MOTENV1_DEBUG_CONNECTION
  MOTENV1_PRINTF("Debug Connection         Enabled\r\n");
#endif /* MOTENV1_DEBUG_CONNECTION */

#ifdef MOTENV1_DEBUG_NOTIFY_TRAMISSION
  MOTENV1_PRINTF("Debug Notify Trasmission Enabled\r\n\n");
#endif /* MOTENV1_DEBUG_NOTIFY_TRAMISSION */

  /* Initialize the BlueNRG */
  Init_BlueNRG_Stack();

  /* Initialize the BlueNRG Custom services */
  Init_BlueNRG_Custom_Services();

  if(TargetBoardFeatures.HWAdvanceFeatures) {
    InitHWFeatures();
  }
  
#ifndef USE_STM32L0XX_NUCLEO
  /* Check the BootLoader Compliance */
  MOTENV1_PRINTF("\r\n");
  if(CheckBootLoaderCompliance()) {
    MOTENV1_PRINTF("BootLoader Compliant with FOTA procedure\r\n\n");
  } else {
    MOTENV1_PRINTF("ERROR: BootLoader NOT Compliant with FOTA procedure\r\n\n");
  }
#endif /* USE_STM32L0XX_NUCLEO */

  /* Set Accelerometer Full Scale to 2G */
  Set2GAccelerometerFullScale();

  /* initialize timers */
  InitTimers();

  /* Infinite loop */
  while (1){
    /* Led Blinking when there is not a client connected */
    if(!connected) {
      if(!TargetBoardFeatures.LedStatus) {
        if(!(HAL_GetTick()&0x3FF)) {
          LedOnTargetPlatform();
        }
      } else {
        if(!(HAL_GetTick()&0x3F)) {
          LedOffTargetPlatform();
        }
      }
    }

    if(set_connectable){
#ifndef USE_STM32L0XX_NUCLEO
      
      /* Code for MotionFX integration - Start Section */
      /* Initialize MotionFX Library */
      if(TargetBoardFeatures.MotionFXIsInitalized==0)
      {
        MotionFX_manager_init();
        MotionFX_manager_start_9X();
        /* Enable magnetometer calibration */
        MagCalibTest();
      }
      /* Code for MotionFX integration - End Section */
      
      /* Code for MotionAR integration - Start Section */
      /* Initialize MotionAR Library */
      if(TargetBoardFeatures.MotionARIsInitalized==0)
        MotionAR_manager_init();
      /* Code for MotionAR integration - End Section */

      /* Code for MotionCP integration - Start Section */
      /* Initialize MotionCP Library */
      if(TargetBoardFeatures.MotionCPIsInitalized==0)
        MotionCP_manager_init();
      /* Code for MotionCP integration - End Section */

      /* Code for MotionGR integration - Start Section */
      /* Initialize MotionGR Library */
      if(TargetBoardFeatures.MotionGRIsInitalized==0)
        MotionGR_manager_init();
      /* Code for MotionGR integration - End Section */

      /* Code for MotionPM integration - Start Section */
      /* Initialize MotionPM Library */
      if(TargetBoardFeatures.MotionPMIsInitalized==0)
        MotionPM_manager_init();
      /* Code for MotionPM integration - End Section */

#ifdef ENABLE_STM32_MOTION_ID
      /* Initialize MotionID Library */
      if(TargetBoardFeatures.MotionIDIsInitalized==0)
        MotionID_manager_init();
#endif /* ENABLE_STM32_MOTION_ID */

      if(NecessityToSaveMetaDataManager) {
        uint32_t Success = EraseMetaDataManager();
        if(Success) {
          SaveMetaDataManager();
        }
      }
#endif /* USE_STM32L0XX_NUCLEO */

      /* Now update the BLE advertize data and make the Board connectable */
      setConnectable();
      set_connectable = FALSE;
    }

    /* handle BLE event */
    if(HCI_ProcessEvent) {
      HCI_ProcessEvent=0;
      HCI_Process();
    }

    /* Handle Interrupt from MEMS */
    if(MEMSInterrupt) {
      MEMSCallback();
      MEMSInterrupt=0;
    }

    /* Handle user button */
    if(ButtonPressed) {
      ButtonCallback();
      ButtonPressed=0;
    }

#ifndef USE_STM32L0XX_NUCLEO
    /* Handle Re-Calibration */
    if(ForceReCalibration)
    {
      ForceReCalibration=0;
      ReCalibration();
    }
#endif /* USE_STM32L0XX_NUCLEO */
    
    /* Environmental Data */
    if(SendEnv) {
      SendEnv=0;
      SendEnvironmentalData();
    }
    
#ifdef STM32_SENSORTILE    
    /* Battery Info Data */
    if(SendBatteryInfo) {
      SendBatteryInfo=0;
      SendBatteryInfoData();
    }
#endif /* STM32_SENSORTILE */

    /* Motion Data */
    if(SendAccGyroMag) {
      SendAccGyroMag=0;
      SendMotionData();
    }

#ifndef USE_STM32L0XX_NUCLEO
    /* MotionFX */
    if(Quaternion) {
      Quaternion=0;
      ComputeQuaternions();
    }

    /* MotionAR */
    if(UpdateMotionAR) {
      UpdateMotionAR=0;
      ComputeMotionAR();
    }

    /* MotionCP */
    if(UpdateMotionCP) {
      UpdateMotionCP=0;
      ComputeMotionCP();
    }

    /* MotionGR */
    if(UpdateMotionGR) {
      UpdateMotionGR=0;
      ComputeMotionGR();
    }

    /* MotionPM */
    if(UpdateMotionPM) {
      UpdateMotionPM=0;
      ComputeMotionPM();
    }

#ifdef ENABLE_STM32_MOTION_ID
    /* MotionID */
    if(UpdateMotionID) {
      UpdateMotionID=0;
      ComputeMotionID();
    }
#endif /* ENABLE_STM32_MOTION_ID */
    
#endif /* USE_STM32L0XX_NUCLEO */
    
    /* Wait for Event */
    __WFI();
  }
}

/**
  * @brief  This function sets the ACC FS to 2g
  * @param  None
  * @retval None
  */
void Set2GAccelerometerFullScale(void)
{
  /* Set Full Scale to +/-2g */
  (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Set_FS_Value_IKS01A2 : BSP_ACCELERO_Set_FS_Value)(TargetBoardFeatures.HandleAccSensor,2.0f);
  
  /* Read the Acc Sensitivity */
  (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_Sensitivity_IKS01A2 : BSP_ACCELERO_Get_Sensitivity)(TargetBoardFeatures.HandleAccSensor,&sensitivity);
  sensitivity_Mul = sensitivity * ((float) FROM_MG_TO_G);
}

/**
  * @brief  This function dsets the ACC FS to 4g
  * @param  None
  * @retval None
  */
void Set4GAccelerometerFullScale(void)
{
  
  /* Set Full Scale to +/-4g */
  (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Set_FS_Value_IKS01A2 : BSP_ACCELERO_Set_FS_Value)(TargetBoardFeatures.HandleAccSensor,4.0f);

  /* Read the Acc Sensitivity */
  (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_Sensitivity_IKS01A2 : BSP_ACCELERO_Get_Sensitivity)(TargetBoardFeatures.HandleAccSensor,&sensitivity);
  sensitivity_Mul = sensitivity * ((float) FROM_MG_TO_G);
}

/**
  * @brief  Output Compare callback in non blocking mode 
  * @param  htim : TIM OC handle
  * @retval None
  */
void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
  uint32_t uhCapture=0;
  /* TIM1_CH1 toggling with frequency = 100Hz */
  if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
  {
    uhCapture = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
    /* Set the Capture Compare Register value */
    __HAL_TIM_SET_COMPARE(&TimCCHandle, TIM_CHANNEL_1, (uhCapture + uhCCR1_Val));
    
#ifndef USE_STM32L0XX_NUCLEO
    if ((W2ST_CHECK_CONNECTION(W2ST_CONNECT_QUAT)) | (W2ST_CHECK_CONNECTION(W2ST_CONNECT_EC))) {
      Quaternion=1;
    }

    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_GR)) {
      UpdateMotionGR=1;
    }
#else /* USE_STM32L0XX_NUCLEO */
    SendEnv=1;
#endif /* USE_STM32L0XX_NUCLEO */
  }

#ifndef USE_STM32L0XX_NUCLEO
  /* TIM1_CH2 toggling with frequency = 50Hz */
  if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2)
  {
    uhCapture = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);
    /* Set the Capture Compare Register value */
    __HAL_TIM_SET_COMPARE(&TimCCHandle, TIM_CHANNEL_2, (uhCapture + DEFAULT_uhCCR2_Val));

    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_CP)) {
      UpdateMotionCP=1;
    } else if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_PM)) {
      UpdateMotionPM=1;
    }
  }

  /* TIM1_CH3 toggling with frequency = 16Hz */
  if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_3)
  {
    uhCapture = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_3);
    /* Set the Capture Compare Register value */
    __HAL_TIM_SET_COMPARE(&TimCCHandle, TIM_CHANNEL_3, (uhCapture + DEFAULT_uhCCR3_Val));

#ifdef ENABLE_STM32_MOTION_ID    
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ID)) {
      UpdateMotionID=1;
    } else
#endif /* ENABLE_STM32_MOTION_ID */
      if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_AR)) {
      UpdateMotionAR=1;
    }
  }
#endif /* USE_STM32L0XX_NUCLEO */

  /* TIM1_CH4 toggling with frequency = 20 Hz */
  if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_4)
  {
     uhCapture = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_4);
    /* Set the Capture Compare Register value */
    __HAL_TIM_SET_COMPARE(&TimCCHandle, TIM_CHANNEL_4, (uhCapture + uhCCR4_Val));
    SendAccGyroMag=1;
  }
}

#ifndef USE_STM32L0XX_NUCLEO
/**
  * @brief  Period elapsed callback in non blocking mode for Environmental timer
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  if(htim == (&TimEnvHandle)) {
    /* Environmental */
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV))
      SendEnv=1;
    
#ifdef STM32_SENSORTILE    
    /* Battery Info */
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_GG_EVENT))
      SendBatteryInfo= 1;
#endif /* STM32_SENSORTILE */
    
#ifdef STM32_SENSORTILE
  #ifdef MOTENV1_ENABLE_PRINTF
    } else if(htim == (&TimHandle)) {
      CDC_TIM_PeriodElapsedCallback(htim);
  #endif /* MOTENV1_ENABLE_PRINTF */
#endif /* STM32_SENSORTILE */
  }
}
#endif /* USE_STM32L0XX_NUCLEO */

/**
  * @brief  Callback for user button
  * @param  None
  * @retval None
  */
static void ButtonCallback(void)
{
#ifndef USE_STM32L0XX_NUCLEO
  /* Only if connected */
  if(connected) {
    static uint32_t HowManyButtonPress=0;
    static uint32_t tickstart=0;
    uint32_t tickstop;

    if(!tickstart)
      tickstart = HAL_GetTick();

    tickstop = HAL_GetTick();

    if((tickstop-tickstart)>2000) {
      HowManyButtonPress=0;
      tickstart=tickstop;
    }


    if(TargetBoardFeatures.MotionFXIsInitalized)
    {
      if((HowManyButtonPress+1)==BLUEMSYS_N_BUTTON_PRESS)
      {
        ForceReCalibration=1;
        HowManyButtonPress=0;
      }
      else
      {
        HowManyButtonPress++;
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM))
        {
           BytesToWrite = sprintf((char *)BufferToWrite, "%ld in %ldmS Reset Calib\r\n",3-HowManyButtonPress,2000-(tickstop-tickstart));
           Term_Update(BufferToWrite,BytesToWrite);
        }
        else
        {
          MOTENV1_PRINTF("%ld in %ldmS Reset Calib\r\n",3-HowManyButtonPress,2000-(tickstop-tickstart));
        }
      }
    }
    else
    {
      MOTENV1_PRINTF("UserButton Pressed\r\n");
    }
  }
#else /* USE_STM32L0XX_NUCLEO */
  MOTENV1_PRINTF("UserButton Pressed\r\n");
#endif /* USE_STM32L0XX_NUCLEO */
}

#ifndef USE_STM32L0XX_NUCLEO
/**
  * @brief  Reset the magneto calibration
  * @param  None
  * @retval None
  */
static void ReCalibration(void)
{
  /* Only if connected */
  if(connected) {
    /* Reset the Compass Calibration */
    isCal=0;
    MFX_MagCal_output_t mag_cal_test;

    /* Notifications of Compass Calibration */
    Config_Notify(FEATURE_MASK_SENSORFUSION_SHORT,W2ST_COMMAND_CAL_STATUS,isCal ? 100: 0);
    Config_Notify(FEATURE_MASK_ECOMPASS,W2ST_COMMAND_CAL_STATUS,isCal ? 100: 0);

    /* Reset the Calibration */
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
       BytesToWrite = sprintf((char *)BufferToWrite, "Force ReCalibration\n\r");
       Term_Update(BufferToWrite,BytesToWrite);
    } else
      MOTENV1_PRINTF("Force ReCalibration\n\r");

    {
      ResetCalibrationInMemory();
    }
    
    /* Enable magnetometer calibration */
    MotionFX_manager_MagCal_start(SAMPLE_PERIOD);
    MotionFX_MagCal_getParams(&mag_cal_test);

    /* Switch off the LED */
    LedOffTargetPlatform();
  }
}
#endif /* USE_STM32L0XX_NUCLEO */

/**
  * @brief  Send Notification where there is a interrupt from MEMS
  * @param  None
  * @retval None
  */
static void MEMSCallback(void)
{
  uint8_t stat = 0;

  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_FREE_FALL)) {
    /* Check if the interrupt is due to Free Fall */
    (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_Free_Fall_Detection_Status_Ext_IKS01A2 : BSP_ACCELERO_Get_Free_Fall_Detection_Status_Ext)(TargetBoardFeatures.HandleAccSensor,&stat);
    if(stat) {
      AccEvent_Notify(ACC_FREE_FALL);
    }
  }

  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_DOUBLE_TAP)) {
    /* Check if the interrupt is due to Double Tap */
    (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_Double_Tap_Detection_Status_Ext_IKS01A2 : BSP_ACCELERO_Get_Double_Tap_Detection_Status_Ext)(TargetBoardFeatures.HandleAccSensor,&stat);
    if(stat) {
      AccEvent_Notify(ACC_DOUBLE_TAP);
    }
  }

  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_SINGLE_TAP)) {
    /* Check if the interrupt is due to Single Tap */
    (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_Single_Tap_Detection_Status_Ext_IKS01A2 : BSP_ACCELERO_Get_Single_Tap_Detection_Status_Ext)(TargetBoardFeatures.HandleAccSensor,&stat);
    if(stat) {
      AccEvent_Notify(ACC_SINGLE_TAP);
    }
  }

  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_WAKE_UP)) {
    /* Check if the interrupt is due to Wake Up */
    (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_Wake_Up_Detection_Status_Ext_IKS01A2 : BSP_ACCELERO_Get_Wake_Up_Detection_Status_Ext)(TargetBoardFeatures.HandleAccSensor,&stat);
    if(stat) {
      AccEvent_Notify(ACC_WAKE_UP);
    }
  }

  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_TILT)) {
    /* Check if the interrupt is due to Tilt */
    (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_Tilt_Detection_Status_Ext_IKS01A2 : BSP_ACCELERO_Get_Tilt_Detection_Status_Ext)(TargetBoardFeatures.HandleAccSensor,&stat);
    if(stat) {
      AccEvent_Notify(ACC_TILT);
    }
  }

  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_6DORIENTATION)) {
    /* Check if the interrupt is due to 6D Orientation */
    (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_6D_Orientation_Status_Ext_IKS01A2 : BSP_ACCELERO_Get_6D_Orientation_Status_Ext)(TargetBoardFeatures.HandleAccSensor,&stat);
    if(stat) {
      AccEventType Orientation = GetHWOrientation6D();
      AccEvent_Notify(Orientation);
    }
  }

  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_PEDOMETER)) {
    /* Check if the interrupt is due to Pedometer */
    (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_Pedometer_Status_Ext_IKS01A2 : BSP_ACCELERO_Get_Pedometer_Status_Ext)(TargetBoardFeatures.HandleAccSensor,&stat);
    if(stat) {
      uint16_t StepCount = GetStepHWPedometer();
      AccEvent_Notify(StepCount);
    }
  }
}

/**
  * @brief  Send Motion Data Acc/Mag/Gyro to BLE
  * @param  None
  * @retval None
  */
static void SendMotionData(void)
{
  SensorAxes_t ACC_Value;
  SensorAxes_t GYR_Value;
  SensorAxes_t MAG_Value;

  /* Read the Acc values */
  (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_Axes_IKS01A2 : BSP_ACCELERO_Get_Axes)(TargetBoardFeatures.HandleAccSensor,&ACC_Value);

  /* Read the Magneto values */
  (TargetBoardFeatures.SnsAltFunc ? BSP_MAGNETO_Get_Axes_IKS01A2 : BSP_MAGNETO_Get_Axes)(TargetBoardFeatures.HandleMagSensor,&MAG_Value);

  /* Read the Gyro values */
  (TargetBoardFeatures.SnsAltFunc ? BSP_GYRO_Get_Axes_IKS01A2 : BSP_GYRO_Get_Axes)(TargetBoardFeatures.HandleGyroSensor,&GYR_Value);

  AccGyroMag_Update(&ACC_Value,&GYR_Value,&MAG_Value);
}

#ifndef USE_STM32L0XX_NUCLEO
/**
  * @brief  MotionCP Working function
  * @param  None
  * @retval None
  */
static void ComputeMotionCP(void)
{  
  static MCP_output_t CarryPositionCodeStored = MCP_UNKNOWN;
  SensorAxesRaw_t ACC_Value_Raw;

  /* Read the Acc RAW values */
  (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_AxesRaw_IKS01A2 : BSP_ACCELERO_Get_AxesRaw)(TargetBoardFeatures.HandleAccSensor,&ACC_Value_Raw);
  MotionCP_manager_run(ACC_Value_Raw);

  if(CarryPositionCodeStored!=CarryPositionCode){
    CarryPositionCodeStored = CarryPositionCode;
    CarryPosRec_Update(CarryPositionCode);

    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
       BytesToWrite = sprintf((char *)BufferToWrite,"Sending: CP=%d\r\n",CarryPositionCode);
       Term_Update(BufferToWrite,BytesToWrite);
    } else {
      MOTENV1_PRINTF("Sending: CP=%d\r\n",CarryPositionCode);
    }
  }
}

/**
  * @brief  MotionGR Working function
  * @param  None
  * @retval None
  */
static void ComputeMotionGR(void)
{
  static MGR_output_t GestureRecognitionCodeStored = MGR_NOGESTURE;
  SensorAxesRaw_t ACC_Value_Raw;

  /* Read the Acc RAW values */
  (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_AxesRaw_IKS01A2 : BSP_ACCELERO_Get_AxesRaw)(TargetBoardFeatures.HandleAccSensor,&ACC_Value_Raw);
  MotionGR_manager_run(ACC_Value_Raw);

  if(GestureRecognitionCodeStored!=GestureRecognitionCode){
    GestureRecognitionCodeStored = GestureRecognitionCode;
    GestureRec_Update(GestureRecognitionCode);

    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
       BytesToWrite = sprintf((char *)BufferToWrite,"Sending: GR=%d\r\n",GestureRecognitionCode);
       Term_Update(BufferToWrite,BytesToWrite);
    } else {
      MOTENV1_PRINTF("Sending: GR=%d\r\n",GestureRecognitionCode);
    }
  }
}

/**
  * @brief  MotionPM Working function
  * @param  None
  * @retval None
  */
static void ComputeMotionPM(void)
{
  static MPM_output_t PM_DataOUTStored;
  SensorAxesRaw_t ACC_Value_Raw;

  /* Read the Acc RAW values */
  (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_AxesRaw_IKS01A2 : BSP_ACCELERO_Get_AxesRaw)(TargetBoardFeatures.HandleAccSensor,&ACC_Value_Raw);
  MotionPM_manager_run(ACC_Value_Raw);

  if((PM_DataOUTStored.Nsteps!=PM_DataOUT.Nsteps) | (PM_DataOUTStored.Cadence!=PM_DataOUT.Cadence)){
    PM_DataOUTStored = PM_DataOUT;
    AccPedo_Update(&PM_DataOUT);
  }
}

/**
  * @brief  MotionAR Working function
  * @param  None
  * @retval None
  */
static void ComputeMotionAR(void)
{
  static MAR_output_t ActivityCodeStored = MAR_NOACTIVITY;
  SensorAxesRaw_t ACC_Value_Raw;

  /* Read the Acc RAW values */
  (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_AxesRaw_IKS01A2 : BSP_ACCELERO_Get_AxesRaw)(TargetBoardFeatures.HandleAccSensor,&ACC_Value_Raw);

  MotionAR_manager_run(ACC_Value_Raw);

  if(ActivityCodeStored!=ActivityCode){
    ActivityCodeStored = ActivityCode;

    ActivityRec_Update(ActivityCode);

    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
       BytesToWrite = sprintf((char *)BufferToWrite,"Sending: AR=%d\r\n",ActivityCode);
       Term_Update(BufferToWrite,BytesToWrite);
    } else {
      MOTENV1_PRINTF("Sending: AR=%d\r\n",ActivityCode);
    }
  }
}

#ifdef ENABLE_STM32_MOTION_ID
/**
  * @brief  MotionID Working function
  * @param  None
  * @retval None
  */
static void ComputeMotionID(void)
{
  static MID_output_t MIDStored = MID_ON_DESK; /* on desk */
  SensorAxesRaw_t ACC_Value_Raw;

  /* Read the Acc RAW values */
  (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_AxesRaw_IKS01A2 : BSP_ACCELERO_Get_AxesRaw)(TargetBoardFeatures.HandleAccSensor,&ACC_Value_Raw);

  MotionID_manager_run(ACC_Value_Raw);

  if(MIDStored!=MIDCode){
    MIDStored = MIDCode;

    IntensityDet_Update(MIDCode);

    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
       BytesToWrite = sprintf((char *)BufferToWrite,"Sending: ID=%d\r\n",MIDCode);
       Term_Update(BufferToWrite,BytesToWrite);
    } else {
      MOTENV1_PRINTF("Sending: ID=%d\r\n",MIDCode);
    }
  }
}
#endif /* ENABLE_STM32_MOTION_ID */

/** @brief  MotionFX Working function
 * @param  None
 * @retval None
 */
static void ComputeQuaternions(void)
{
  static SensorAxes_t quat_axes[SEND_N_QUATERNIONS];
  static int32_t calibIndex =0;
  static int32_t CounterFX  =0;
  static int32_t CounterEC  =0;
  SensorAxesRaw_t ACC_Value_Raw;
  SensorAxes_t GYR_Value;
  SensorAxes_t MAG_Value;
  
  MFX_MagCal_input_t mag_data_in;

  /* Increment the Counter */
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_EC)) {
    CounterEC++;
  } else {
    CounterFX++;
  }

  /* Read the Acc RAW values */
  (TargetBoardFeatures.SnsAltFunc ? BSP_ACCELERO_Get_AxesRaw_IKS01A2 : BSP_ACCELERO_Get_AxesRaw)(TargetBoardFeatures.HandleAccSensor,&ACC_Value_Raw);

  /* Read the Magneto values */
  (TargetBoardFeatures.SnsAltFunc ? BSP_MAGNETO_Get_Axes_IKS01A2 : BSP_MAGNETO_Get_Axes)(TargetBoardFeatures.HandleMagSensor,&MAG_Value);

  /* Read the Gyro values */
  (TargetBoardFeatures.SnsAltFunc ? BSP_GYRO_Get_Axes_IKS01A2 : BSP_GYRO_Get_Axes)(TargetBoardFeatures.HandleGyroSensor,&GYR_Value);
      
  /* Check if is calibrated */
  if(isCal!=0x01){
    /* Run Compass Calibration @ 25Hz */
    calibIndex++;
    if (calibIndex == 4){
      calibIndex = 0;
      mag_data_in.mag[0]= MAG_Value.AXIS_X * FROM_MGAUSS_TO_UT50;
      mag_data_in.mag[1]= MAG_Value.AXIS_Y * FROM_MGAUSS_TO_UT50;
      mag_data_in.mag[2]= MAG_Value.AXIS_Z * FROM_MGAUSS_TO_UT50;
      mag_data_in.time_stamp = mag_time_stamp;
      mag_time_stamp += SAMPLE_PERIOD;
      MotionFX_manager_MagCal_run(&mag_data_in, &magOffset);
      
      /* Control the calibration status */
      if( (magOffset.cal_quality == MFX_MAGCALOK) ||
          (magOffset.cal_quality == MFX_MAGCALGOOD) )
      {
        isCal= 1;
        
        MAG_Offset.AXIS_X= (int32_t)(magOffset.hi_bias[0] * FROM_UT50_TO_MGAUSS);
        MAG_Offset.AXIS_Y= (int32_t)(magOffset.hi_bias[1] * FROM_UT50_TO_MGAUSS);
        MAG_Offset.AXIS_Z= (int32_t)(magOffset.hi_bias[2] * FROM_UT50_TO_MGAUSS);
        
        /* Disable magnetometer calibration */
        MotionFX_manager_MagCal_stop(SAMPLE_PERIOD);
      }
        
      if(isCal == 0x01){
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
          BytesToWrite = sprintf((char *)BufferToWrite, "Compass Calibrated\n\r");
          Term_Update(BufferToWrite,BytesToWrite);
        } else {
          MOTENV1_PRINTF("Compass Calibrated\n\r");
        }

        /* Switch on the Led */
        LedOnTargetPlatform();
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_LED)) {
          LED_Update(TargetBoardFeatures.LedStatus);
        }

        /* Notifications of Compass Calibration */
        Config_Notify(FEATURE_MASK_SENSORFUSION_SHORT,W2ST_COMMAND_CAL_STATUS,isCal ? 100: 0);
        Config_Notify(FEATURE_MASK_ECOMPASS,W2ST_COMMAND_CAL_STATUS,isCal ? 100: 0);
      }
    }
  }else {
    calibIndex=0;
  }
  
  MotionFX_manager_run(ACC_Value_Raw,GYR_Value,MAG_Value);

  /* Read the quaternions */
  MFX_output_t *MotionFX_Engine_Out = MotionFX_manager_getDataOUT();

  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_EC)) {
    /* E-Compass Updated every 0.1 Seconds*/
    if(CounterEC==10) {
      uint16_t Angle = (uint16_t)trunc(100*MotionFX_Engine_Out->heading_9X);
      CounterEC=0;
      ECompass_Update(Angle);
    }
  } else {
    int32_t QuaternionNumber = (CounterFX>SEND_N_QUATERNIONS) ? (SEND_N_QUATERNIONS-1) : (CounterFX-1);

    /* Scaling quaternions data by a factor of 10000
      (Scale factor to handle float during data transfer BT) */

    /* Save the quaternions values */
    if(MotionFX_Engine_Out->quaternion_9X[3] < 0){
      quat_axes[QuaternionNumber].AXIS_X = (int32_t)(MotionFX_Engine_Out->quaternion_9X[0] * (-10000));
      quat_axes[QuaternionNumber].AXIS_Y = (int32_t)(MotionFX_Engine_Out->quaternion_9X[1] * (-10000));
      quat_axes[QuaternionNumber].AXIS_Z = (int32_t)(MotionFX_Engine_Out->quaternion_9X[2] * (-10000));
    } else {
      quat_axes[QuaternionNumber].AXIS_X = (int32_t)(MotionFX_Engine_Out->quaternion_9X[0] * 10000);
      quat_axes[QuaternionNumber].AXIS_Y = (int32_t)(MotionFX_Engine_Out->quaternion_9X[1] * 10000);
      quat_axes[QuaternionNumber].AXIS_Z = (int32_t)(MotionFX_Engine_Out->quaternion_9X[2] * 10000);
    }
      
    /* Every QUAT_UPDATE_MUL_10MS*10 mSeconds Send Quaternions informations via bluetooth */
    if(CounterFX==QUAT_UPDATE_MUL_10MS){
      Quat_Update(quat_axes);
      CounterFX=0;
    }
  }
}
#endif /* USE_STM32L0XX_NUCLEO */

/**
  * @brief  Send Environmetal Data (Temperature/Pressure/Humidity) to BLE
  * @param  None
  * @retval None
  */
static void SendEnvironmentalData(void)
{
  uint8_t Status;

#ifdef MOTENV1_DEBUG_NOTIFY_TRAMISSION
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
     BytesToWrite = sprintf((char *)BufferToWrite,"Sending: ");
     Term_Update(BufferToWrite,BytesToWrite);
  } else {
    MOTENV1_PRINTF("Sending: ");
  }
#endif /* MOTENV1_DEBUG_NOTIFY_TRAMISSION */

  /* Notifications of Compass Calibration status*/
  if(FirstConnectionConfig) {
    Config_Notify(FEATURE_MASK_SENSORFUSION_SHORT,W2ST_COMMAND_CAL_STATUS,isCal ? 100: 0);
    Config_Notify(FEATURE_MASK_ECOMPASS,W2ST_COMMAND_CAL_STATUS,isCal ? 100: 0);
#ifdef MOTENV1_DEBUG_NOTIFY_TRAMISSION
     if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
       BytesToWrite = sprintf((char *)BufferToWrite,"Cal=%d ",isCal);
       Term_Update(BufferToWrite,BytesToWrite);
     } else {
      MOTENV1_PRINTF("Cal=%d ",isCal);
     }
#endif /* MOTENV1_DEBUG_NOTIFY_TRAMISSION */
    FirstConnectionConfig=0;
    
    /* Switch on/off the LED according to calibration */
    if(isCal){
      LedOnTargetPlatform();
    } else {
      LedOffTargetPlatform();
    }

    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_LED)) {
      LED_Update(TargetBoardFeatures.LedStatus);
    }
  }

  /* Pressure,Humidity, and Temperatures*/
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV)) {
    float SensorValue;
    int32_t PressToSend=0;
    uint16_t HumToSend=0;
    int16_t Temp2ToSend=0,Temp1ToSend=0;
    int32_t decPart, intPart;

    if(TargetBoardFeatures.HandlePressSensor) {
      if((TargetBoardFeatures.SnsAltFunc ? BSP_PRESSURE_IsInitialized_IKS01A2 : BSP_PRESSURE_IsInitialized)(TargetBoardFeatures.HandlePressSensor,&Status)==COMPONENT_OK) {
        (TargetBoardFeatures.SnsAltFunc ? BSP_PRESSURE_Get_Press_IKS01A2 : BSP_PRESSURE_Get_Press)(TargetBoardFeatures.HandlePressSensor,(float *)&SensorValue);
        MCR_BLUEMS_F2I_2D(SensorValue, intPart, decPart);
        PressToSend=intPart*100+decPart;
#ifdef MOTENV1_DEBUG_NOTIFY_TRAMISSION
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
          BytesToWrite = sprintf((char *)BufferToWrite,"Press=%ld ",PressToSend);
          Term_Update(BufferToWrite,BytesToWrite);
        } else {
          MOTENV1_PRINTF("Press=%ld ",PressToSend);
        }
#endif /* MOTENV1_DEBUG_NOTIFY_TRAMISSION */
      }
    }
   
    if(TargetBoardFeatures.HandleHumSensor) {
      if((TargetBoardFeatures.SnsAltFunc ? BSP_HUMIDITY_IsInitialized_IKS01A2 : BSP_HUMIDITY_IsInitialized)(TargetBoardFeatures.HandleHumSensor,&Status)==COMPONENT_OK){
        (TargetBoardFeatures.SnsAltFunc ? BSP_HUMIDITY_Get_Hum_IKS01A2 : BSP_HUMIDITY_Get_Hum)(TargetBoardFeatures.HandleHumSensor,(float *)&SensorValue);
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
        HumToSend = intPart*10+decPart;
#ifdef MOTENV1_DEBUG_NOTIFY_TRAMISSION
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
          BytesToWrite = sprintf((char *)BufferToWrite,"Hum=%d ",HumToSend);
          Term_Update(BufferToWrite,BytesToWrite);
        } else {
          MOTENV1_PRINTF("Hum=%d ",HumToSend);
        }
#endif /* MOTENV1_DEBUG_NOTIFY_TRAMISSION */
      }
    }

    if(TargetBoardFeatures.NumTempSensors==2) {
      if((TargetBoardFeatures.SnsAltFunc ? BSP_TEMPERATURE_IsInitialized_IKS01A2 : BSP_TEMPERATURE_IsInitialized)(TargetBoardFeatures.HandleTempSensors[0],&Status)==COMPONENT_OK){
        (TargetBoardFeatures.SnsAltFunc ? BSP_TEMPERATURE_Get_Temp_IKS01A2 : BSP_TEMPERATURE_Get_Temp)(TargetBoardFeatures.HandleTempSensors[0],(float *)&SensorValue);
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
        Temp1ToSend = intPart*10+decPart; 
#ifdef MOTENV1_DEBUG_NOTIFY_TRAMISSION
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
          BytesToWrite = sprintf((char *)BufferToWrite,"Temp=%d ",Temp1ToSend);
          Term_Update(BufferToWrite,BytesToWrite);
        } else {
          MOTENV1_PRINTF("Temp=%d ",Temp1ToSend);
        }
#endif /* MOTENV1_DEBUG_NOTIFY_TRAMISSION */
      }

      if((TargetBoardFeatures.SnsAltFunc ? BSP_TEMPERATURE_IsInitialized_IKS01A2 : BSP_TEMPERATURE_IsInitialized)(TargetBoardFeatures.HandleTempSensors[1],&Status)==COMPONENT_OK){
        (TargetBoardFeatures.SnsAltFunc ? BSP_TEMPERATURE_Get_Temp_IKS01A2 : BSP_TEMPERATURE_Get_Temp)(TargetBoardFeatures.HandleTempSensors[1],(float *)&SensorValue);
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
        Temp2ToSend = intPart*10+decPart;
#ifdef MOTENV1_DEBUG_NOTIFY_TRAMISSION
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
          BytesToWrite = sprintf((char *)BufferToWrite,"Temp2=%d ",Temp2ToSend);
          Term_Update(BufferToWrite,BytesToWrite);
        } else {
          MOTENV1_PRINTF("Temp2=%d ",Temp2ToSend);
        }
#endif /* MOTENV1_DEBUG_NOTIFY_TRAMISSION */
      }
    } else if(TargetBoardFeatures.NumTempSensors==1) {
      if((TargetBoardFeatures.SnsAltFunc ? BSP_TEMPERATURE_IsInitialized_IKS01A2 : BSP_TEMPERATURE_IsInitialized)(TargetBoardFeatures.HandleTempSensors[0],&Status)==COMPONENT_OK){
        (TargetBoardFeatures.SnsAltFunc ? BSP_TEMPERATURE_Get_Temp_IKS01A2 : BSP_TEMPERATURE_Get_Temp)(TargetBoardFeatures.HandleTempSensors[0],(float *)&SensorValue);
        MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
        Temp1ToSend = intPart*10+decPart;
#ifdef MOTENV1_DEBUG_NOTIFY_TRAMISSION
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
          BytesToWrite = sprintf((char *)BufferToWrite,"Temp1=%d ",Temp1ToSend);
          Term_Update(BufferToWrite,BytesToWrite);
        } else {
          MOTENV1_PRINTF("Temp1=%d ",Temp1ToSend);
        }
#endif /* MOTENV1_DEBUG_NOTIFY_TRAMISSION */
      }
    }
    Environmental_Update(PressToSend,HumToSend,Temp2ToSend,Temp1ToSend);
  }

#ifdef MOTENV1_DEBUG_NOTIFY_TRAMISSION
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
     BytesToWrite = sprintf((char *)BufferToWrite,"\r\n");
     Term_Update(BufferToWrite,BytesToWrite);
  } else {
    MOTENV1_PRINTF("\r\n");
  }
#endif /* MOTENV1_DEBUG_NOTIFY_TRAMISSION */
}

#ifdef STM32_SENSORTILE
/**
  * @brief  Send Battery Info Data (Voltage/Current/Soc) to BLE
  * @param  None
  * @retval None
  */
static void SendBatteryInfoData(void)
{
  uint32_t voltage, soc;
  int32_t current;
  uint8_t v_mode;
  
  /* Update Gas Gouge Status */
  BSP_GG_Task(TargetBoardFeatures.HandleGGComponent,&v_mode);

  /* Read the Gas Gouge Status */
  BSP_GG_GetVoltage(TargetBoardFeatures.HandleGGComponent, &voltage);
  BSP_GG_GetCurrent(TargetBoardFeatures.HandleGGComponent, &current);
  BSP_GG_GetSOC(TargetBoardFeatures.HandleGGComponent, &soc);
  
#ifdef MOTENV1_DEBUG_NOTIFY_TRAMISSION
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
     BytesToWrite = sprintf((char *)BufferToWrite,"Battery Report:\r\n");
     Term_Update(BufferToWrite,BytesToWrite);
  } else {
    MOTENV1_PRINTF("Battery Report:\r\n");
  }
#endif /* MOTENV1_DEBUG_NOTIFY_TRAMISSION */

  /* Battery Informations */
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_GG_EVENT)) {
    GG_Update(soc, voltage, current);
#ifdef MOTENV1_DEBUG_NOTIFY_TRAMISSION
     if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
       BytesToWrite = sprintf((char *)BufferToWrite,"Charge= %ld%% Voltage=%ld mV Current= %ld mA", soc, voltage, current);
       Term_Update(BufferToWrite,BytesToWrite);
     } else {
       MOTENV1_PRINTF("Charge= %d%% Voltage=%d mV Current= %d mA", soc, voltage, current);
     }
#endif /* MOTENV1_DEBUG_NOTIFY_TRAMISSION */
  }

#ifdef MOTENV1_DEBUG_NOTIFY_TRAMISSION
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
     BytesToWrite = sprintf((char *)BufferToWrite,"\r\n");
     Term_Update(BufferToWrite,BytesToWrite);
  } else {
    MOTENV1_PRINTF("\r\n");
  }
#endif /* MOTENV1_DEBUG_NOTIFY_TRAMISSION */
}
#endif /* STM32_SENSORTILE */


#ifndef USE_STM32L0XX_NUCLEO
/**
  * @brief  CRC init function.
  * @param  None
  * @retval None
  */
static void MX_CRC_Init(void)
{
  hcrc.Instance = CRC;

  if (HAL_CRC_Init(&hcrc) != HAL_OK)
  {
    Error_Handler();
  }
}
#endif /* USE_STM32L0XX_NUCLEO */

/**
* @brief  Function for initializing timers for sending the information to BLE:
 *  - 1 for sending MotionFX/AR/CP and Acc/Gyro/Mag
 *  - 1 for sending the Environmental info
 * @param  None
 * @retval None
 */
static void InitTimers(void)
{
  uint32_t uwPrescalerValue;

  /* Timer Output Compare Configuration Structure declaration */
  TIM_OC_InitTypeDef sConfig;

#ifndef USE_STM32L0XX_NUCLEO
  /* Compute the prescaler value to have TIM4 counter clock equal to 2 KHz */
  uwPrescalerValue = (uint32_t) ((SystemCoreClock / 2000) - 1);
  
  /* Set TIM4 instance (Environmental)*/
  TimEnvHandle.Instance = TIM4;
  /* Initialize TIM4 peripheral */
  TimEnvHandle.Init.Period = 50*20 - 1;
  TimEnvHandle.Init.Prescaler = uwPrescalerValue;
  TimEnvHandle.Init.ClockDivision = 0;
  TimEnvHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&TimEnvHandle) != HAL_OK) {
    /* Initialization Error */
  }
#endif /* USE_STM32L0XX_NUCLEO */
  

  /* Compute the prescaler value to have TIM4 counter clock equal to 10 KHz */
  uwPrescalerValue = (uint32_t) ((SystemCoreClock / 10000) - 1); 
  
  /* Set TIM1 instance (Motion)*/
#if ((defined (USE_STM32F4XX_NUCLEO)) || (defined (USE_STM32L4XX_NUCLEO)))
  TimCCHandle.Instance = TIM1;
#elif (defined (USE_STM32L0XX_NUCLEO))
  TimCCHandle.Instance = TIM2;
#endif 
  TimCCHandle.Init.Period        = 65535;
  TimCCHandle.Init.Prescaler     = uwPrescalerValue;
  TimCCHandle.Init.ClockDivision = 0;
  TimCCHandle.Init.CounterMode   = TIM_COUNTERMODE_UP;
  if(HAL_TIM_OC_Init(&TimCCHandle) != HAL_OK)
  {
    /* Initialization Error */
    Error_Handler();
  }
  
 /* Configure the Output Compare channels */
 /* Common configuration for all channels */
  sConfig.OCMode     = TIM_OCMODE_TOGGLE;
  sConfig.OCPolarity = TIM_OCPOLARITY_LOW;

  /* Output Compare Toggle Mode configuration: Channel1 */
  sConfig.Pulse = DEFAULT_uhCCR1_Val;
  if(HAL_TIM_OC_ConfigChannel(&TimCCHandle, &sConfig, TIM_CHANNEL_1) != HAL_OK)
  {
    /* Configuration Error */
    Error_Handler();
  }
  
#ifndef USE_STM32L0XX_NUCLEO
  /* Output Compare Toggle Mode configuration: Channel2 */
  sConfig.Pulse = DEFAULT_uhCCR2_Val;
  if(HAL_TIM_OC_ConfigChannel(&TimCCHandle, &sConfig, TIM_CHANNEL_2) != HAL_OK)
  {
    /* Configuration Error */
    Error_Handler();
  }
  
  /* Output Compare Toggle Mode configuration: Channel3 */
  sConfig.Pulse = DEFAULT_uhCCR3_Val;
  if(HAL_TIM_OC_ConfigChannel(&TimCCHandle, &sConfig, TIM_CHANNEL_3) != HAL_OK)
  {
    /* Configuration Error */
    Error_Handler();
  }
#endif /* USE_STM32L0XX_NUCLEO */
  
  /* Output Compare Toggle Mode configuration: Channel4 */
  sConfig.Pulse = DEFAULT_uhCCR4_Val;
  if(HAL_TIM_OC_ConfigChannel(&TimCCHandle, &sConfig, TIM_CHANNEL_4) != HAL_OK)
  {
    /* Configuration Error */
    Error_Handler();
  }
}

/** @brief Initialize the BlueNRG Stack
 * @param None
 * @retval None
 */
static void Init_BlueNRG_Stack(void)
{
  const char BoardName[8] = {NAME_BLUEMS,0};
  uint16_t service_handle, dev_name_char_handle, appearance_char_handle;
  int ret;
  uint8_t  hwVersion;
  uint16_t fwVersion;

#ifdef MAC_BLUEMS
  {
    uint8_t tmp_bdaddr[6]= {MAC_BLUEMS};
    int32_t i;
    for(i=0;i<6;i++)
      bdaddr[i] = tmp_bdaddr[i];
  }
#endif /* MAC_BLUEMS */
  
#ifndef STM32_NUCLEO
  /* Initialize the BlueNRG SPI driver */
  BNRG_SPI_Init();
#endif /* STM32_NUCLEO */
  
  /* Initialize the BlueNRG HCI */
  HCI_Init();
    
  /* Reset BlueNRG hardware */
  BlueNRG_RST();

  /* get the BlueNRG HW and FW versions */
  getBlueNRGVersion(&hwVersion, &fwVersion);

  if (hwVersion > 0x30) {
    /* X-NUCLEO-IDB05A1 expansion board is used */
    TargetBoardFeatures.bnrg_expansion_board = IDB05A1;
  } else {
    /* X-NUCLEO-IDB0041 expansion board is used */
    TargetBoardFeatures.bnrg_expansion_board = IDB04A1;
  }
  
  /* 
   * Reset BlueNRG again otherwise it will fail.
   */
  BlueNRG_RST();

#ifndef MAC_BLUEMS
  #ifdef MAC_STM32UID_BLUEMS
  /* Create a Unique BLE MAC Related to STM32 UID */
  {
    bdaddr[0] = (STM32_UUID[1]>>24)&0xFF;
    bdaddr[1] = (STM32_UUID[0]    )&0xFF;
    bdaddr[2] = (STM32_UUID[2] >>8)&0xFF;
    bdaddr[3] = (STM32_UUID[0]>>16)&0xFF;
#ifdef STM32_NUCLEO
    /* if IDB05A1 = Number between 100->199
     * if IDB04A1 = Number between 0->99
     * where Y == (MOTENV1_VERSION_MAJOR + MOTENV1_VERSION_MINOR)&0xF */
    bdaddr[4] = (hwVersion > 0x30) ?
         ((((MOTENV1_VERSION_MAJOR-48)*10) + (MOTENV1_VERSION_MINOR-48)+100)&0xFF) :
         ((((MOTENV1_VERSION_MAJOR-48)*10) + (MOTENV1_VERSION_MINOR-48)    )&0xFF) ;
#else /* STM32_NUCLEO */
    bdaddr[4] = (((MOTENV1_VERSION_MAJOR-48)*10) + (MOTENV1_VERSION_MINOR-48)+100)&0xFF;
#endif  /* STM32_NUCLEO */
    bdaddr[5] = 0xC0; /* for a Legal BLE Random MAC */
  }
  #else /* MAC_STM32UID_BLUEMS */
  {
    /* we will let the BLE chip to use its Random MAC address */
    uint8_t data_len_out;
    ret = aci_hal_read_config_data(CONFIG_DATA_RANDOM_ADDRESS, 6, &data_len_out, bdaddr);

    if(ret){
      MOTENV1_PRINTF("\r\nReading  Random BD_ADDR failed\r\n");
      goto fail;
    }
  }
  #endif /* MAC_STM32UID_BLUEMS */
#else /* MAC_BLUEMS */
  ret = aci_hal_write_config_data(CONFIG_DATA_PUBADDR_OFFSET,
                                  CONFIG_DATA_PUBADDR_LEN,
                                  bdaddr);

  if(ret){
     MOTENV1_PRINTF("\r\nSetting Pubblic BD_ADDR failed\r\n");
     goto fail;
  }
#endif /* MAC_BLUEMS */

  ret = aci_gatt_init();    
  if(ret){
     MOTENV1_PRINTF("\r\nGATT_Init failed\r\n");
     goto fail;
  }

  if (TargetBoardFeatures.bnrg_expansion_board == IDB05A1) {
    ret = aci_gap_init_IDB05A1(GAP_PERIPHERAL_ROLE_IDB05A1, 0, 0x07, &service_handle, &dev_name_char_handle, &appearance_char_handle);
  }else {
    ret = aci_gap_init_IDB04A1(GAP_PERIPHERAL_ROLE_IDB04A1, &service_handle, &dev_name_char_handle, &appearance_char_handle);
  }

  if(ret != BLE_STATUS_SUCCESS){
     MOTENV1_PRINTF("\r\nGAP_Init failed\r\n");
     goto fail;
  }

#ifndef  MAC_BLUEMS
  #ifdef MAC_STM32UID_BLUEMS
    ret = hci_le_set_random_address(bdaddr);

    if(ret){
       MOTENV1_PRINTF("\r\nSetting the Static Random BD_ADDR failed\r\n");
       goto fail;
    }
  #endif /* MAC_STM32UID_BLUEMS */
#endif /* MAC_BLUEMS */

  ret = aci_gatt_update_char_value(service_handle, dev_name_char_handle, 0,
                                   7/*strlen(BoardName)*/, (uint8_t *)BoardName);

  if(ret){
     MOTENV1_PRINTF("\r\naci_gatt_update_char_value failed\r\n");
    while(1);
  }

  ret = aci_gap_set_auth_requirement(MITM_PROTECTION_REQUIRED,
                                     OOB_AUTH_DATA_ABSENT,
                                     NULL, 7, 16,
                                     USE_FIXED_PIN_FOR_PAIRING, 123456,
                                     BONDING);
  if (ret != BLE_STATUS_SUCCESS) {
     MOTENV1_PRINTF("\r\nGAP setting Authentication failed\r\n");
     goto fail;
  }

  MOTENV1_PRINTF("SERVER: BLE Stack Initialized \r\n"
         "\t\tBoard type=%s HWver=%d, FWver=%d.%d.%c\r\n"
         "\t\tBoardName= %s\r\n"
         "\t\tBoardMAC = %x:%x:%x:%x:%x:%x\r\n\n",
         (TargetBoardFeatures.bnrg_expansion_board==IDB05A1) ? "IDB05A1" : "IDB04A1",
         hwVersion,
         fwVersion>>8,
         (fwVersion>>4)&0xF,
         (hwVersion > 0x30) ? ('a'+(fwVersion&0xF)-1) : 'a',
         BoardName,
         bdaddr[5],bdaddr[4],bdaddr[3],bdaddr[2],bdaddr[1],bdaddr[0]);

  /* Set output power level */
  aci_hal_set_tx_power_level(1,4);

  return;

fail:
  return;
}
  
/** @brief Initialize all the Custom BlueNRG services
 * @param None
 * @retval None
 */
static void Init_BlueNRG_Custom_Services(void)
{
  int ret;
  
  ret = Add_HWServW2ST_Service();
  if(ret == BLE_STATUS_SUCCESS) {
     MOTENV1_PRINTF("HW      Service W2ST added successfully\r\n");
  } else {
     MOTENV1_PRINTF("\r\nError while adding HW Service W2ST\r\n");
  }

  ret = Add_SWServW2ST_Service();
  if(ret == BLE_STATUS_SUCCESS) {
     MOTENV1_PRINTF("SW      Service W2ST added successfully\r\n");
  } else {
     MOTENV1_PRINTF("\r\nError while adding SW Service W2ST\r\n");
  }

  ret = Add_ConsoleW2ST_Service();
  if(ret == BLE_STATUS_SUCCESS) {
     MOTENV1_PRINTF("Console Service W2ST added successfully\r\n");
  } else {
     MOTENV1_PRINTF("\r\nError while adding Console Service W2ST\r\n");
  }

  ret = Add_ConfigW2ST_Service();
  if(ret == BLE_STATUS_SUCCESS) {
     MOTENV1_PRINTF("Config  Service W2ST added successfully\r\n\n");
  } else {
     MOTENV1_PRINTF("\r\nError while adding Config Service W2ST\r\n\n");
  }
}

#ifdef USE_STM32F4XX_NUCLEO
/**
  * @brief  System Clock Configuration
  *         The system Clock is configured as follow:
  *            System Clock source            = PLL (HSI)
  *            SYSCLK(Hz)                     = 84000000
  *            HCLK(Hz)                       = 84000000
  *            AHB Prescaler                  = 1
  *            APB1 Prescaler                 = 2
  *            APB2 Prescaler                 = 1
  *            HSI Frequency(Hz)              = 16000000
  *            PLL_M                          = 16
  *            PLL_N                          = 336
  *            PLL_P                          = 4
  *            PLL_Q                          = 7
  *            VDD(V)                         = 3.3
  *            Main regulator output voltage  = Scale2 mode
  *            Flash Latency(WS)              = 2
  * @param  None
  * @retval None
  */
static void SystemClock_Config(void)
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;

  /* Enable Power Control clock */
  __PWR_CLK_ENABLE();

  /* The voltage scaling allows optimizing the power consumption when the device is
     clocked below the maximum system frequency, to update the voltage scaling value
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);

  /* Enable HSI Oscillator and activate PLL with HSI as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 0x10;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 16;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK){
    Error_Handler();
  }

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK){
    Error_Handler();
  }
}
#endif /* USE_STM32F4XX_NUCLEO */

#ifdef USE_STM32L4XX_NUCLEO
#ifdef STM32_NUCLEO
/**
  * @brief  System Clock Configuration
  *         The system Clock is configured as follow : 
  *            System Clock source            = PLL (MSI)
  *            SYSCLK(Hz)                     = 80000000
  *            HCLK(Hz)                       = 80000000
  *            AHB Prescaler                  = 1
  *            APB1 Prescaler                 = 1
  *            APB2 Prescaler                 = 1
  *            MSI Frequency(Hz)              = 4000000
  *            PLL_M                          = 1
  *            PLL_N                          = 40
  *            PLL_R                          = 2
  *            PLL_P                          = 7
  *            PLL_Q                          = 4
  *            Flash Latency(WS)              = 4
  * @param  None
  * @retval None
  */
static void SystemClock_Config(void)
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;

  /* MSI is enabled after System reset, activate PLL with MSI as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 40;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLP = 7;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK){
    /* Initialization Error */
    while(1);
  }
  
  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 
     clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;  
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;  
  if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) {
    /* Initialization Error */
    while(1);
  }
}
#elif STM32_SENSORTILE
/**
* @brief  System Clock Configuration
* @param  None
* @retval None
*/
void SystemClock_Config(void)
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
  
  __HAL_RCC_PWR_CLK_ENABLE();
  HAL_PWR_EnableBkUpAccess();
  
  /* Enable the LSE Oscilator */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK){
    while(1);
  }
  
  /* Enable the CSS interrupt in case LSE signal is corrupted or not present */
  HAL_RCCEx_DisableLSECSS();
  
  /* Enable MSI Oscillator and activate PLL with MSI as source */
  RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState            = RCC_MSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.MSIClockRange       = RCC_MSIRANGE_11;
  RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_MSI;
  RCC_OscInitStruct.PLL.PLLM            = 6;
  RCC_OscInitStruct.PLL.PLLN            = 40;
  RCC_OscInitStruct.PLL.PLLP            = 7;
  RCC_OscInitStruct.PLL.PLLQ            = 4;
  RCC_OscInitStruct.PLL.PLLR            = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK){
    while(1);
  }
  
  /* Enable MSI Auto-calibration through LSE */
  HAL_RCCEx_EnableMSIPLLMode();
  
  /* Select MSI output as USB clock source */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_MSI;
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
  
  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 
  clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK){
    while(1);
  }
}
#endif /* STM32_NUCLEO */
#endif /* USE_STM32L4XX_NUCLEO */

#ifdef USE_STM32L0XX_NUCLEO
/**
  * @brief  System Clock Configuration
  *         The system Clock configuration
  * @param  None
  * @retval None
  */
static void SystemClock_Config(void)
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  __PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 0x10;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_4;
  RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_2;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);

  __SYSCFG_CLK_ENABLE();
}
#endif /* USE_STM32L0XX_NUCLEO */

/**
  * @brief This function provides accurate delay (in milliseconds) based 
  *        on variable incremented.
  * @note This is a user implementation using WFI state
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
void HAL_Delay(__IO uint32_t Delay)
{
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
  while((HAL_GetTick() - tickstart) < Delay){
    __WFI();
  }
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
void Error_Handler(void)
{
  /* User may add here some code to deal with this error */
  while(1){
  }
}

/**
 * @brief  EXTI line detection callback.
 * @param  uint16_t GPIO_Pin Specifies the pins connected EXTI line
 * @retval None
 */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{  
  switch(GPIO_Pin){
#ifdef STM32_NUCLEO
    case SPI1_CMN_DEFAULT_IRQ_PIN:
#else
    case BNRG_SPI_EXTI_PIN:
#endif /* STM32_NUCLEO */   
      HCI_Isr();
      HCI_ProcessEvent=1;
    break;
#ifdef STM32_NUCLEO
  case KEY_BUTTON_PIN:
    ButtonPressed = 1;
    break;
#endif /* STM32_NUCLEO */

#ifdef STM32_NUCLEO
#ifdef USE_STM32L0XX_NUCLEO
  #ifdef IKS01A1
    case M_INT1_PIN:
  #elif IKS01A2
    case LSM6DSL_INT1_O_PIN:
  #endif /* IKS01A1 */
#else /* USE_STM32L0XX_NUCLEO */
    case M_INT1_PIN:
    case LSM6DSL_INT1_O_PIN:
#endif /* USE_STM32L0XX_NUCLEO */
#elif STM32_SENSORTILE
  case LSM6DSM_INT2_PIN:
#endif /* STM32_NUCLEO */
    MEMSInterrupt=1;
    break;
  }
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t* file, uint32_t line)
{ 
  /* User can add his own implementation to report the file name and line number,
     ex: MOTENV1_PRINTF("Wrong parameters value: file %s on line %d\r\n", file, line) */

  /* Infinite loop */
  while (1){
  }
}
#endif

#ifndef USE_STM32L0XX_NUCLEO

/**
 * @brief  Test if calibration data are available
 * @param  None
 * @retval None
 */
static void MagCalibTest(void)
{
  MFX_MagCal_output_t mag_cal_test;
  
  /* Recall the calibration Credential saved */
  MotionFX_manager_MagCal_start(SAMPLE_PERIOD);
  MotionFX_MagCal_getParams(&mag_cal_test);
    
  if(CalibrationData[0]== BLUEMSYS_CHECK_CALIBRATION) {
#ifdef STM32_NUCLEO
    if(CalibrationData[1] == TargetBoardFeatures.SnsAltFunc) {
#endif /* STM32_NUCLEO */
      
      if( (mag_cal_test.cal_quality == MFX_MAGCALOK) ||
          (mag_cal_test.cal_quality == MFX_MAGCALGOOD) )
      {
        MAG_Offset.AXIS_X = (int32_t) (mag_cal_test.hi_bias[0] * FROM_UT50_TO_MGAUSS);
        MAG_Offset.AXIS_Y = (int32_t) (mag_cal_test.hi_bias[1] * FROM_UT50_TO_MGAUSS);
        MAG_Offset.AXIS_Z = (int32_t) (mag_cal_test.hi_bias[2] * FROM_UT50_TO_MGAUSS);

        isCal =1;
        
        MOTENV1_PRINTF("Magneto Calibration Read\r\n");
      }
      else
      {
        isCal =0;
        MOTENV1_PRINTF("Magneto Calibration quality is not good\r\n");
      }
#ifdef STM32_NUCLEO
    } else {
      MOTENV1_PRINTF("Magneto Calibration Not correct for Current %s board\r\n",TargetBoardFeatures.SnsAltFunc ? "IKS01A2" : "IKS01A1");
      ResetCalibrationInMemory();
      MotionFX_manager_MagCal_start(SAMPLE_PERIOD);
      MotionFX_MagCal_getParams(&mag_cal_test);      
      isCal=0;
    }
#endif /* STM32_NUCLEO */
  } else {
    MOTENV1_PRINTF("Magneto Calibration Not present\r\n");
    isCal=0;
  }
  
  if(!isCal)
  {
    MAG_Offset.AXIS_X = 0;
    MAG_Offset.AXIS_Y = 0;
    MAG_Offset.AXIS_Z = 0;
  }
}

/**
 * @brief  Check if there are a valid Calibration Values in Memory and read them
 * @param uint32_t *MagnetoCalibration the Magneto Calibration
 * @retval unsigned char Success/Not Success
 */
unsigned char ReCallCalibrationFromMemory(uint16_t dataSize, uint32_t *data)
{
  /* ReLoad the Calibration Values from RAM */
  unsigned char Success=0;
  
  int i;
  
  /* Recall the calibration Credential saved */
  MDM_ReCallGMD(GMD_CALIBRATION,(void *)&CalibrationData);
  
  for(i=0; i<dataSize; i++)
  {
    data[i]= CalibrationData[i+2];
  }

  return Success;
}

/**
 * @brief  Save the Magnetometer Calibration Values to Memory
 * @param uint32_t *MagnetoCalibration the Magneto Calibration
 * @retval unsigned char Success/Not Success
 */
unsigned char SaveCalibrationToMemory(uint16_t dataSize, uint32_t *data)
{
  unsigned char Success=1;
  
  int i;

  if(Success) {
    /* Store in RAM */
    
    CalibrationData[0] = BLUEMSYS_CHECK_CALIBRATION;
    CalibrationData[1] = TargetBoardFeatures.SnsAltFunc;
    
    for(i=0; i<dataSize; i++)
    {
      CalibrationData[i+2]= data[i];
    }
 
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
     BytesToWrite = sprintf((char *)BufferToWrite, "Magneto Calibration will be saved in FLASH\r\n");
     Term_Update(BufferToWrite,BytesToWrite);
    } else {
      MOTENV1_PRINTF("Magneto Calibration will be saved in FLASH\r\n");
    }

    MDM_SaveGMD(GMD_CALIBRATION,(void *)&CalibrationData);
    
    NecessityToSaveMetaDataManager=1;
  }

  return Success;
}

/**
 * @brief  Reset the Magnetometer Calibration Values in Memory
 * @param uint32_t *MagnetoCalibration the Magneto Calibration
 * @retval unsigned char Success/Not Success
 */
static unsigned char ResetCalibrationInMemory(void)
{
  /* Reset Calibration Values in RAM */
  unsigned char Success=1;
  int32_t Counter;

  for(Counter=0;Counter<29;Counter++)
    CalibrationData[Counter]=0x0;
    //CalibrationData[Counter]=0xFFFFFFFF;

  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
     BytesToWrite = sprintf((char *)BufferToWrite, "Magneto Calibration will be eresed in FLASH\r\n");
     Term_Update(BufferToWrite,BytesToWrite);
  } else {
    MOTENV1_PRINTF("Magneto Calibration will be eresed in FLASH\r\n");
  }
  
  MDM_SaveGMD(GMD_CALIBRATION,(void *)&CalibrationData);

  NecessityToSaveMetaDataManager=1;
  return Success;
}

#endif /* USE_STM32L0XX_NUCLEO */

/******************* (C) COPYRIGHT 2017 STMicroelectronics *****END OF FILE****/
